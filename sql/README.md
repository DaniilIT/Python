# SQL

**Structured Query Language** - язык запросов, предназначенный для создания, обработки и хранения баз данных (DB), и представляет собой простую линейную последовательность операторов.

[вопросы на собеседовании](https://tproger.ru/articles/sql-interview-questions/)\
[графический дизайн архитектур DB](https://app.dbdesigner.net/designer)\
[codecademy](https://www.codecademy.com/learn/learn-sql)\
[MySQL](https://proglib.io/p/mysql-queries)
[группы операций](https://sky.pro/media/gruppy-operatorov-sql/)


## База данных

\- упорядоченная структура хранения иформации преимущественно больших объемов.

- **реляционные** (от слова "отношение") данные хранятся в виде связных таблиц.
- **нереляционные** данные хранятся иначе, например в виде хэш-таблиц, дерева и т. д.


### СУБД

**Система Управления Базы Данных** - ПО, которое обрабатывает SQL опросы на получение, изменение и удаление информации из DB.

**DB** $\Leftrightarrow$ **СУБД** $\Leftrightarrow$ **SQL-запросы**

- **реляционные**
    - MySQL - используется web-разработчиками для создания диномических сайтов;
	- MariaDB - форк от MySQL более производительный и с улучшенной безопасностью;
    - Oracle - коммерческая СУБД, используется в бизнесе и для банковских операций;
    - PostgreSQL - бесплатная алтернатива Oracle, с полной поддержкой стандарта SQL;
- **нереляционные**
    - MongoDB - для хранения документов JSON;
    - Cassandra - СУБД для распределенной DB на нескольких сереверах;
    - Redis - для обработки DB в оперативной памяти;

**pgAdmin** - это инструмент для администрирования базы данных PostgreSQL на уровне сервера.\
**DBeaver** - это универсальный инструмент для работы с разными СУБД на уровне пользователя.


## [SQLite](https://docs.python.org/3/library/sqlite3.html)

<img src="images/SQLite.svg" alt="SQLite logo" title="SQLite logo" style="height: 380px;"/>

\- легковесная реляционная СУБД для создания локальных баз данных, встраиваемых в приложения или веб-сайты на уровне сервера без клиент-серверной архитектуры и состоящаяиз одного файла с раширением `.db`.

```python
import sqlite3

connection = sqlite3.connect('dbname.db')  # управляет подключением у файлу DB
cursor = connection.cursor()  # объект для получения данных из DB

query = "<ТЕКСТ ЗАПРОСА>"
cursor.execute(query)
cur.executescript(queries)  # выполнение нескольких запросов, разделенных ';'

cursor.fetchall()  # получаем результат в виде списка кортежей (строки)
cursor.fetchone()  # получаем одну строку

connection.commit()  # завиксировать изменения
connection.close()
```

**SQL-запросы** состоят из ключевых слов.


### Выборка данных

&#10158; **SELECT** - извлечение данных;\
&#10158; **FROM** - определение таблицы;

```python
with sqlite3.connect('dbname.db') as con:
    cur = con.cursor()

    # извлечь все данные из таблицы
    query = """
        SELECT *
        FROM tname
    """
    cur.execute(query)
    
    # получить список названий столбцов
    column_headings = [heading[0] for heading in cursor.description]
    
    for row in cur.fetchall():
        print(row)
```

выбрать некоторые поля
```sql
SELECT col1, col2
FROM tname
```


### Фильтрация

&#10158; **WHERE** - фильтрация данных поля (которое может и не быть в SELECT);

Операторы условий:
* = равно;
* \> больше;
* \<= меньше или равно;
* \<> (!=) не равно;
* NOT, AND, OR логические операторы;
* BETWEEN соответствует значению, находящемуся в указанном диапозоне;
* IN определяет набор значений;
* LIKE соответствует шаблонному выражению;
* IS NULL соответствует отсутствующему значению;

```sql
WHERE col1 BETWEN 10 AND 20  -- границы включены
AND col2 LIKE 'R%'  -- начинается с буквы R # % пропус подстроки # _ пропуск одного символа
AND col3 IN ('A', 'B')
```


### Ограничение вывода

&#10158; **LIMIT** - сколько строк вывести;\
&#10158; **OFSET** - сколько строк пропустить перед выводом;

```sql
LIMIT 10 OFSET 100 -- выведет строки с 100 по 109
```


### Сортировка

&#10158; **ORDER BY** - сортировка **ASC** повозрастанию / **DESC** поубыванию;

```sql
ORDER BY col1, col2 DESC  -- ASC по-умолчанию
```


### Группировка

&#10158; **GROUP BY** - создание новой таблицы группировкой по уникальным значениям поля (которое должно быть в SELECT), что позволяет применить агрегирующую функцию по группам;

```sql
GROUP BY col1, col2
```


### Агрегирующие функции

вычисляют обобщенное значений чаще всего по группам.

* COUNT(col) - считает кольчество **не null** строк в поле;
* SUM() - суммирует значения числового поля;
* AVG() - считает среднее (average) арифметическое числового поля;
* MIN() / MAX() - находят минимальное и максимальное значение поля;

посчитать количество строк в таблице
```sql
SELECT COUNT(*)
FROM tname
```

```sql
SELECT col1, SUM(col2), MAX(col2)
FROM tname
GROUP BY col1
```


### Алиасы

\- названия новых полей после группировки и применения агрегирующих функций

```sql
SELECT col1, SUM(col2) as col2_sum, MAX(col2) as col2_max
FROM tname
GROUP BY col1
```


### Фильтрация по результату агрегирующей функции

&#10158; **HEVING** - фильтрация сгруппированных строк;

```sql
SELECT col1, SUM(col2) as col2_sum, MAX(col2) as col2_max
FROM tname
WHERE col3 = 'A'
GROUP BY col1
HAVING MAX(col2) > 10
ORDER BY col2_max
```

***

## Управление DB

### Создание DB

DB создается локально при 1-ом подключении.

```sql
con = sqlite3.connect('dbname') 
```


## Управление таблицей


### Создание таблицы

При создании таблицы определяется тип столбцов:
* BIT - 0 / 1;
* INT - числовые значени (4байта) $\pm$2 млрд;
* DECIMAL - числовые значени с фиксированной точностью (для денежных значений);
* FLOAT - числовые значени с плавающей точкой;
* VARCHAR(n) - текст в кодировке ASCII в 1 байт для латиницы, max 8000 (еще есть TEXT без указания длины);
* NVARCHAR(n) - текст в кодировке Unicode в 2 байт для кирилицы, max 4000;
* DATE - даты от 0000-01-01 по 9999-12-31;
* TIME - время от 00:00:00.0000000 по 23:59:59.9999999;
* DATETIME - дата и время от 1753-01-01 по 9999-12.31;
* BLOB - бинарные файлы;

```sql
CREATE TABLE tname (
    col1 INT,
    col2 VARCHAR(40),
    col3 DATE,
    col4 VARCHAR(40)
)
```

```python
from datetime import datetime

date_string = '2023-02-26 15:34:55.123'
date_time = datetime.strptime(date_string, '%Y-%m-%d %H:%M:%S.%f')

# Добавление даты в SQLite
cursor.execute("""
	INSERT INTO tname
	(col_date) VALUES (?)
""", (date_time,))
```


При создании таблицы рекомендуется указывать ограничения для заполнения данными с помощью модификаторов:

```sql
CREATE TABLE tname (
    col1 INT UNIQUE,
    col2 VARCHAR(40) NOT NULL,
    col3 DATE CONSTRAINT CK_col3 CHECK (col3 >= '1996-01-01'),
    col4 FLOAT CONSTRAINT DF_col4 DEFAULT 'Undefined'
)
```


### Индекс

\- позволяет ускорить выполнение поиска данных, так как он предварительно отсортирован по значению, но требует выделения памяти.

при создании
INDEX idx_name_age (name, age)

как отдельный запрос
CREATE INDEX index_name ON tname (name, age);

```sql
CREATE [UNIQUE] INDEX index_name
ON tname (col1);
```

удаление индекса
```sql
DROP INDEX index_name;
```

### PRIMARY KEY

**Первичный ключ** - столбец, который уникально идетифицирует строку в таблице и предназначен для связи между таблицами.

составной первичный ключ для связи many to many


Id INT PRIMARY KEY AUTO_INCREMENT


### изменение таблицы

&#10158; **ALTER TABLE tname**\
&#10158; ADD col type\
&#10158; RENAME col TO col_new\
&#10158; DROP COLUMN col  # в sqlite не поддерживает динамическое изменение колонок

```sql
ALTER TABLE tname
ADD col4 INT
```

### удаление таблицы

&#10158; **TRUNCATE TABLE tname** - удаление всех данных таблицы
&#10158; **DROP TABLE tname** - удаление таблицы


## Управление данными


### Добавление данных

&#10158; **INSERT INTO tname (col1, col2) VALUES (val1, val2)**

```sql
INSERT INTO tname
VALUES (val1, val2, ...)
```

вставить данные из другой таблицы
```sql
INSERT INTO tname_2
SELECT *
FROM tname_1
WHERE condition
```

### Изменение данных

&#10158; **UPDATE tname SET col1 = 'val1_new'**

```sql
UPDATE tname
SET col1 = 'val1_new'
WHERE col2 > 10;
```

### Удаление данных

&#10158; **DELETE FROM tname**

удалить строку с индексом равным 1
```sql
DELETE FROM tname
WHERE Id = 1;
```


## Связь таблиц

Типы связей:
* **one to one**\
    выглядит, как две части одной таблицы, разделенной по вертикали\
    например: человек - паспорт
* **one to many**\
    каждая одна строчка одной таблице может имеет связь с несколькоми строчками в другой, но не наоборот\
    например: пользователи - покупки
* **many to many**\
    связь между объектами, записанными в двух таблицах, если каждый из них может иметь несколько связей со строками в другой таблице\
    например: фильмы - актеры


### FOREIGN KEY

**Внешний ключ** - столбец, который соответствует первичному ключу в другой таблице (обычно устанавливается в подчиненной), он позволяет:
* связывать таблицы между собой;
* указать поведение при удалении или изменении строки в главной таблице;

модификаторы:
* ON DELETE - указание действий при удалении строки в главной таблице
* ON UPDATE - указание действий при изменении строки в главной таблице

опции:
* CASCADE - автоматичически удаляет/изменяет строки в зависимой таблице
* SET NULL - устанавливает значение NULL для столбца внешнего ключа в зависимой таблице
* SET DEFAULT - устанавливает значение из CONSTRAINT DEFAULT для столбца внешнего ключа в зависимой таблице
* RESTRICT - запрещает удаление/изменение строк в главное таблице, если есть связные строки

```sql
CREATE TABLE tname_2 (
    Id INT PRIMARY KEY,
    Title VARCHAR(40),
    tname_1_Id,
    FOREIGN KEY (tname_1_Id) REFERENCES tname_1 (Id) ON DELETE CASCADE
)
```


## Объединение таблиц

1) INNER JOIN - пересечение двух таблиц
2) LEFT JOIN - все значения из первой таблицы и их пересечения со второй
3) RIGHT JOIN - все значения из второй таблицы и их пересечения со первной (= LEFT JOIN у второй таблицы)
4) OUTER JOIN - full

```sql
SELECT tname_1.col1 as t1_col1, tname_2.col1 as t2_col1
FROM tname_1
INNER JOIN tname_2
ON tname_1.id = tname_2.id
```

## Нормальная форма

\- требования, которые должна выполнять DB, чтобы свести к минимому ошибки в результате выборки или изменения данных.

1) Не должно быть наборов значений в одной строке (перечисления через ',' должны быть преобразованы в несколько строк)
2) Все атрибуты должны зависеть от заголовка (одна таблица - один обьект)
3) Не должно быть повторяющихся значений, применимых к нескольким записям.

